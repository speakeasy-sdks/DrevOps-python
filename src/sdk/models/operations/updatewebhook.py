"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class UpdateWebhookRequestBodyEvents(str, Enum):
    WORKFLOW_COMPLETED = 'workflow-completed'
    JOB_COMPLETED = 'job-completed'


@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class UpdateWebhookRequestBody:
    r"""The parameters for an update webhook request"""
    events: Optional[list[UpdateWebhookRequestBodyEvents]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('events'), 'exclude': lambda f: f is None }})
    r"""Events that will trigger the webhook"""
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the webhook"""
    signing_secret: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signing-secret'), 'exclude': lambda f: f is None }})
    r"""Secret used to build an HMAC hash of the payload and passed as a header in the webhook request"""
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)"""
    verify_tls: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('verify-tls'), 'exclude': lambda f: f is None }})
    r"""Whether to enforce TLS certificate verification when delivering the webhook"""
    




@dataclasses.dataclass
class UpdateWebhookRequest:
    webhook_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'webhook-id', 'style': 'simple', 'explode': False }})
    r"""ID of the webhook (UUID)"""
    request_body: Optional[UpdateWebhookRequestBody] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})
    



@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class UpdateWebhookDefaultApplicationJSON:
    r"""Error response."""
    message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message'), 'exclude': lambda f: f is None }})
    


class UpdateWebhookWebhookEvents(str, Enum):
    WORKFLOW_COMPLETED = 'workflow-completed'
    JOB_COMPLETED = 'job-completed'


@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class UpdateWebhookWebhookScope:
    r"""The scope in which the relevant events that will trigger webhooks"""
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""ID of the scope being used (at the moment, only project ID is supported)"""
    type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Type of the scope being used"""
    



@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class UpdateWebhookWebhook:
    r"""A webhook"""
    created_at: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created-at'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""The date and time the webhook was created."""
    events: list[UpdateWebhookWebhookEvents] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('events') }})
    r"""Events that will trigger the webhook"""
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""The unique ID of the webhook"""
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the webhook"""
    scope: UpdateWebhookWebhookScope = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scope') }})
    r"""The scope in which the relevant events that will trigger webhooks"""
    signing_secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signing-secret') }})
    r"""Masked value of the secret used to build an HMAC hash of the payload and passed as a header in the webhook request"""
    updated_at: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updated-at'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""The date and time the webhook was last updated."""
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""URL to deliver the webhook to. Note: protocol must be included as well (only https is supported)"""
    verify_tls: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('verify-tls') }})
    r"""Whether to enforce TLS certificate verification when delivering the webhook"""
    




@dataclasses.dataclass
class UpdateWebhookResponse:
    content_type: str = dataclasses.field()
    status_code: int = dataclasses.field()
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)
    update_webhook_default_application_json_object: Optional[UpdateWebhookDefaultApplicationJSON] = dataclasses.field(default=None)
    r"""Error response."""
    webhook: Optional[UpdateWebhookWebhook] = dataclasses.field(default=None)
    r"""A webhook"""
    

